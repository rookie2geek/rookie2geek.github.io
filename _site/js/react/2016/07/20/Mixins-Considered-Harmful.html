<!DOCTYPE html>
<html>    
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Mixins Considered Harmful</title>
  <meta name="description" content="该文是Mixins Considered Harmful的译文，原作者 Dan Abramov">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://rookie-nerd.github.io/js/react/2016/07/20/Mixins-Considered-Harmful.html">
  <link rel="alternate" type="application/atom+xml" title="Rookie-nerd's Tech Notes" href="http://rookie-nerd.github.io/feed.xml" />
  <script src="/scripts/jquery-1.11.2.min.js"></script>
  <script src="/scripts/pithy.js"></script>
  <script src="/scripts/toc.js"></script>
</head>


  <body>
    <header class="header">
	<div class="header-container">
		<div class="nav">
			
				<li>
					<a href="/index.html">home</a>
				</li>			
			
			
				<li>
					<a href="/archive.html">archive</a>
				</li>			
			
			
				<li>
					<a href="/category.html">category</a>
				</li>			
			
			
				<li>
					<a href="/about.html">about</a>
				</li>			
			
		</div>
		<div class="description">  </div>		
		<ul class="social-links">
			<li>
				<a href="https://github.com/" title="Github">
					<img width="19px" height="19px" src="/images/github.png"/>
				</a>
			</li>
			<li>
				<a href="/feed.xml" title="RSS">
					<img width="19px" height="19px" src="/images/rss.png"/>
				</a>
			</li>
			<li>
				<a href="https://twitter.com/" title="Twitter">
					<img width="19px" height="19px" src="/images/twitter.png"/>
				</a>
			</li>
		</ul>		
	</div>
</header>

    <br>
    <div class="page-content">
      <div class="wrapper">
        <div class="post">
  <div id="toc"></div>
  <br>
  <header class="post-header">
    <h1 class="post-title">Mixins Considered Harmful</h1>
    <p class="post-meta">Jul 20, 2016</p>
  </header>

  <article class="post-content">
    <p>该文是<a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html">Mixins Considered Harmful</a>的译文，原作者 Dan Abramov</p>

<h1 id="section">概述</h1>
<p>“如何在几个组件之间共享代码？”可能是开发者刚开始使用React的时候最先会问到的问题之一。而我们的答案总是永远使用组件组合来提高代码的复用率。你可以定义一个组件，然后在其他的组件中使用它。</p>

<p>但是事实上，不是所有的模式都能够通过组合来实现的。React受到函数式编程的影响，但它却处在一个面向对象库占统治地位的领域。想让Facebook内外的开发者放弃他们所熟悉的模式是非常困难的。</p>

<p>为了降低学习曲线，我们在React中引进了一些特定的安全舱。mixin系统就是其中之一。其目的是为了解决当你不确定如何使用组合来解决代码复用性问题的时候，能够在不同的组件之间使用mixin共享代码。</p>

<p>距离React第一次发布已经3年过去了，整个世界都已经变了，很多View库都开始采用和React差不多的组件模型。使用组合而不是继承来构建声明式的用户界面已经不是特别新颖的方式了。我们对React组件模型也更加自信。不论在facebook还是在社区，我们已经见识了很多对该模型的创新性的使用。</p>

<p>本文主要考虑mixin带来的问题，对于一些case，我们给出了一些替代的方式。我们发现这些替代方式比mixin能更好的处理代码的复杂度。</p>

<h1 id="why-mixins-are-broken">Why Mixins are Broken</h1>
<p>在Facebook，React的使用已经从几个简单的组件扩展到成千上万个。从这些组件中，我们可以看到开发者是如何使用React的。多亏了React的声明式定义和从上到下的数据流展示，很多开发组在发布新特性的时候解决了很多bug。</p>

<p>然而不可避免的是，我们的一些React代码慢慢变得不可理解。偶尔的，我们发现会存在一些组件，没有人愿意去触碰。这些组件太脆弱了，对于新开发者来说也太难理解，最后当初写这些组件的人也忘记了当初为什么要这么实现。而这些脆弱的组件中大部分的不可理解都是来自mixin。</p>

<p>这不是说mixin本身不好。人们在很多不同的语言和场景中成功使用了他们，包括一些函数式语言。在Facebook，我们大量使用Hack中的traits，traits和mixins非常的相似。但是我们认为在React中，mixin不是必须的，而且容易造成问题。下面就说说原因。</p>

<h1 id="mixins-introduce-implicit-dependenciestldr">Mixins introduce implicit dependencies(tl;dr)</h1>
<p>有时候，一个组件会依赖mixin中定义的特定的方法，例如<code class="highlighter-rouge">getClassName()</code>。有些时候是反过来，mixin调用了组件的一些方法，例如<code class="highlighter-rouge">renderHeader()</code>。JavaScript是动态语言，所以想要记录这些依赖是非常困难的。</p>

<p>通常来说，在组件文件中重命名出现的state key或者方法是安全的，但Mixins打破了这个传统。你可能写了一个stateful的组件，然后你的同事可能加了一个mixin读取这个state。几个月之后，你可能发现你想要把state移到其父组件上，这样兄弟组件之间就可以共享这个state。你还会记得更新mixin去读取props么？如果其他很多组件也在使用这个mixin，咋整？</p>

<p>这些隐形的依赖让新来的开发者很难往代码库提交代码。组件的render方法可能指向了一些不是在这个类中定义的方法。那么移除它是否是安全的呢？也许其定义在其中的一个mixin中。但是，是其中的哪一个呢?你需要从mixin的列表中打开他们中的每一个去查找这个方法。更糟糕的是，mixins可以指定自己的mixins，也就是说搜索可能是递归的！</p>

<p>mixins经常会依赖其他的mixins，移除其中的一个，会导致别的也挂掉。在这种情况下，想要了解数据是如果流入和流出mixin是非常困难的，想要对依赖有个整体的了解也是比较困难的。不像组件，mixins不强制要求层级：他们是扁平的，在相同的namespace下工作。</p>

<h1 id="mixins-cause-name-clashestldr">Mixins cause name clashes(tl;dr)</h1>
<p>没有机制保证两个特定的mixins可能在一起工作。例如<code class="highlighter-rouge">FluxListenerMixin</code>定义了<code class="highlighter-rouge">hanleChange()</code>，而<code class="highlighter-rouge">WindowSizeMixin</code>也定义了<code class="highlighter-rouge">handleChange()</code>，你就不能同时使用他们。你也不能在自己的组件中定义<code class="highlighter-rouge">handleChange()</code>。</p>

<p>如果你能修改mixins的源码，这也许不是挺大的一个事儿。当遇到冲突的时候，大不了对于其中一个mixin的名字重命名就好了。但是这其实是不保险的，因为很可能其他地方已经在使用这个方法了，你需要找到使用的地方并且修复这些调用。</p>

<p>如果你的冲突来自第三方的mixin，那事儿就大了，你没法直接重命名mixin，你只能修改自己的组件的名字来解决这个问题。</p>

<p>而且，对于mixin的作者来说，情况也好不到哪里去。即使对mixin增加一个新方法，也有可能导致调用者调用失败，因为调用者可能已经有一个相同的名字了，或者和其他mixin冲突了。一旦mixin写完了，其就很难被移除或者改变。这样丑陋的代码就会因为重构太tricky而不能得到修复。</p>

<h1 id="mixins-cause-snowballing-complexitytldr">Mixins cause snowballing complexity（tl;dr）</h1>
<p>虽然mixins的出发点是简单的，最终他们还是会变得复杂。下面这个例子是我在一个代码中看到的真实的情况。</p>

<p>一个组件需要一些state来记录鼠标的hover。为了复用这些逻辑，你可能会抽出<code class="highlighter-rouge">handleMouseEnter</code>，<code class="highlighter-rouge">handleMouseLeave</code>，<code class="highlighter-rouge">isHovering</code>等方法到<code class="highlighter-rouge">HoverMixin</code>。然后其他人想要实现tooltip。他们不想要重复<code class="highlighter-rouge">HoverMixin</code>中的逻辑，所以他们在<code class="highlighter-rouge">ToolTipMixin</code>中使用了<code class="highlighter-rouge">HoverMixin</code>。<code class="highlighter-rouge">ToolTipMixin</code>在<code class="highlighter-rouge">componentDidUpdate()</code>中读取了<code class="highlighter-rouge">HoverMixin</code>提供的<code class="highlighter-rouge">isHovering</code>来决定展示还是隐藏tooltip。</p>

<p>几个月之后，一些人希望能够对tooltip的方向做一些控制。为了避免代码重复，在<code class="highlighter-rouge">TooltipMixin</code>中增加了<code class="highlighter-rouge">getToolTipOptions</code>方法。这样展示popovers的组件也是用HoverMixin。然而popovers需要不同的hover delay。为了解决这个，一些人在<code class="highlighter-rouge">ToolTipMixin</code>中实现了<code class="highlighter-rouge">getHoverOptions</code>。现在两个mixins已经紧紧地耦合在一起了。</p>

<p>如果没有新的需求，这还是可以接受的。但是这种解决方案并不能很好的伸缩。如果你想要在一个组件中展示多个tooltip怎么办？你不能在一个组件中定义两个一样的mixin。如果tooltip的展示不是在hover的情况下，而是在教学使用中怎么办？最好将<code class="highlighter-rouge">TooltipMix</code>和<code class="highlighter-rouge">HoverMixin</code>解耦。如果hover的地方和tooltip展示的地方不是在一个组件中怎么办？你不能轻易的提升mixin中使用的state到父组件。不像组件，mixins并不能很好的处理这些变化。</p>

<p>每一个新的变化都会导致mixins更加难于理解。使用相同mixin的组件会随着时间的推移，耦合越来越大。任何新的能力都会被加到使用这个mixin的组件中。不存在一种方式将mixin拆分出简单的一部分来使用，而不带来代码重复或者更多依赖和间接性。慢慢的，封装的边界就变模糊了，他们变得越来越抽象，直到没有人能够理解他们。</p>

<p>而这些是我们在使用React之前就面对的相同的问题。我们发现这些问题可以通过声明式展示，单向数据流，封装好的组件来解决。在Facebook，我们已经开始使用其他模型来说替代mixin，通常来说，结果还是令人欣喜的。下面就介绍下这些模式。</p>

<h1 id="migrating-from-mixins">Migrating from Mixins</h1>
<p>首先要声明的是：mixins并没有被废弃。如果你继续使用React.createClass(),那么可能你需要继续使用它们。我们只是说在我们的实践中，mixin不怎么好维护，因此我们不建议使用mixins。</p>

<p>下面的每一块说明了facebook使用mixin的一种模式。对于每一种模型，我们描述了其问题，然后给出一种我们认为更好的解决方案。例子是用ES5写的，但如果你不在需要使用mixins，你可以使用ES6 classes。</p>

<p>希望大家能发现这个列表的一点用处。如果有我们没有覆盖到的场景，请知会我们。</p>

<h2 id="performance-optimizations">Performance Optimizations</h2>
<p>最常使用的mixins是<code class="highlighter-rouge">PureRenderMixin</code>。你可能已经在你的一些组件中使用它来实现当props以及state和之前的相比相同的时候避免不必要的re-renders。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">PureRenderMixin</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'react-addons-pure-render-mixin'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">Button</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">mixins</span><span class="p">:</span> <span class="p">[</span><span class="nx">PureRenderMixin</span><span class="p">],</span>

  <span class="c1">// ...</span>

<span class="p">});</span>
</code></pre>
</div>

<h3 id="section-1">解决方案</h3>
<p>你可以直接使用shallowCompare函数来解决这个问题</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">shallowCompare</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'react-addons-shallow-compare'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">Button</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">shouldComponentUpdate</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">shallowCompare</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="c1">// ...</span>

<span class="p">});</span>
</code></pre>
</div>

<p>如果你使用了自定义的mixin，该mixin在<code class="highlighter-rouge">shouldComponentUpdate</code>函数中实现了不同的算法，我们建议export一个函数，然后直接调用它。</p>

<p>我们明白码更多的代码可能非常让人烦恼。更多时候，我们假话引入一个新的base类，叫做<code class="highlighter-rouge">React.PureComponent</code>。其使用和<code class="highlighter-rouge">PureRenderMixin</code>相同的shallow comparision的方法。</p>

<h3 id="subscriptions-and-side-effects">Subscriptions and Side Effects</h3>
<p>第二大经常使用的场景是将组建租车到第三方的数据源。不论数据源是Flux Store或者RxObservable或者其他的，该模式是非常相似的：在<code class="highlighter-rouge">componentDidMount</code>中注册，在<code class="highlighter-rouge">componentWillUnMount</code>中摧毁，注册的回调会调用<code class="highlighter-rouge">this.setState()</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">SubscriptionMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">getInitialState</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
    <span class="p">};</span>
  <span class="p">},</span>

  <span class="na">componentDidMount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">DataSource</span><span class="p">.</span><span class="nx">addChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="na">componentWillUnmount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">DataSource</span><span class="p">.</span><span class="nx">removeChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="na">handleChange</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
      <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">CommentList</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">mixins</span><span class="p">:</span> <span class="p">[</span><span class="nx">SubscriptionMixin</span><span class="p">],</span>

  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Reading comments from state managed by mixin.</span>
    <span class="kd">var</span> <span class="nx">comments</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">comments</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="nx">comments</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comment</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Comment</span> <span class="nx">comment</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">}</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="p">})}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">CommentList</span><span class="p">;</span>
</code></pre>
</div>

<h3 id="section-2">解决方案</h3>
<p>如果仅仅只有一个组件注册到该data source，那么将注册的逻辑放到组件中是无可厚非的。避免过早的抽象。</p>

<p>如果几个组件使用该mixin来注册到数据源，我们可以使用“higher-order components”模型来解决这个问题。听起来很吓人的样子。我们近距离来看看组件模型如何实现该模式。</p>

<h4 id="higher-order-components-explained">Higher-Order Components Explained</h4>
<p>让我们暂时忘记React。考虑下面这两个方法，数字的加法和乘法，当他们在计算的时候记录结果。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">addAndLog</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'result:'</span> <span class="o">+</span> <span class="nx">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">multiplyAndLog</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'result:'</span> <span class="o">+</span> <span class="nx">result</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>假如我们想把loging的逻辑抽取出来。我们改如何实现呢？一种比较优雅的方式是写“higher-order function”。也就是一个函数，接收一个函数作为参数，并返回新函数。</p>

<p>结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">withLogging</span><span class="p">(</span><span class="nx">wrappedFunction</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 返回具有相同API的函数</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 调用原始的函数</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">wrappedFunction</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="c1">// 依然log结果</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'result:'</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">withLogging</code> higher-order function让我们通过<code class="highlighter-rouge">add</code>和<code class="highlighter-rouge">mutiply</code>方法来实现带有log的<code class="highlighter-rouge">addAndLog</code>和<code class="highlighter-rouge">mutiplyAndLog</code>方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">multiply</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">withLogging</span><span class="p">(</span><span class="nx">wrappedFunction</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">wrappedFunction</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'result:'</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Equivalent to writing addAndLog by hand:</span>
<span class="kd">var</span> <span class="nx">addAndLog</span> <span class="o">=</span> <span class="nx">withLogging</span><span class="p">(</span><span class="nx">add</span><span class="p">);</span>

<span class="c1">// Equivalent to writing multiplyAndLog by hand:</span>
<span class="kd">var</span> <span class="nx">multiplyAndLog</span> <span class="o">=</span> <span class="nx">withLogging</span><span class="p">(</span><span class="nx">multiply</span><span class="p">);</span>
</code></pre>
</div>

<p>Higher-order组件是非常类似的，只是其是使用在React的组件上面。我们将分两步来实现mixins到该模式的转变。</p>

<p>首先，我们将<code class="highlighter-rouge">CommentList</code>组件拆分成两部分，儿子和父亲。儿子仅负责展示评论、父亲处理注册以及通过props传递最新的数据给儿子。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// This is a child component.</span>
<span class="c1">// It only renders the comments it receives as props.</span>
<span class="kd">var</span> <span class="nx">CommentList</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Note: now reading from props rather than state.</span>
    <span class="kd">var</span> <span class="nx">comments</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">comments</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="nx">comments</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comment</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Comment</span> <span class="nx">comment</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">}</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="p">})}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// This is a parent component.</span>
<span class="c1">// It subscribes to the data source and renders &lt;CommentList /&gt;.</span>
<span class="kd">var</span> <span class="nx">CommentListWithSubscription</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">getInitialState</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
    <span class="p">};</span>
  <span class="p">},</span>

  <span class="na">componentDidMount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">DataSource</span><span class="p">.</span><span class="nx">addChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="na">componentWillUnmount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">DataSource</span><span class="p">.</span><span class="nx">removeChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="na">handleChange</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
      <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
    <span class="p">});</span>
  <span class="p">},</span>

  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// We pass the current state as props to CommentList.</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">CommentList</span> <span class="nx">comments</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">comments</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span>  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">CommentListWithSubscription</span><span class="p">;</span>
</code></pre>
</div>

<p>只剩下最后一步要做的了。</p>

<p>还记得我们是如何实现<code class="highlighter-rouge">withLogging()</code>的么？将一个函数作为参数，然后返回一个包装了这个函数的新的函数。</p>

<p>我们将写一个新的函数叫做<code class="highlighter-rouge">withSubscription(WrappedComponent)</code>。其参数可以是任何React组件。我们将<code class="highlighter-rouge">CommentList</code>作为<code class="highlighter-rouge">WrappedComponent</code>，但是我们也可以将其他任何组件作为<code class="highlighter-rouge">WrappedComponent</code>。</p>

<p>该函数将返回另一个组件。该组件负责管理注册以及使用当前数据展示<code class="highlighter-rouge">&lt;WrappedComponent /&gt;</code>。
我们将这种模式叫做 higher-order component。</p>

<p>该组合发生在React render阶段，而不是直接的函数调用。这也就是为什么wrapped component是通过createClass定义和还是ES6 class或者函数无关紧要的原因。如果wrappedComponent是React组件，那么使用<code class="highlighter-rouge">withSubscription()</code>定义的组件能够render。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// This function takes a component...</span>
<span class="kd">function</span> <span class="nx">withSubscription</span><span class="p">(</span><span class="nx">WrappedComponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...and returns another component...</span>
  <span class="k">return</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
    <span class="na">getInitialState</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
      <span class="p">};</span>
    <span class="p">},</span>

    <span class="na">componentDidMount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// ... that takes care of the subscription...</span>
      <span class="nx">DataSource</span><span class="p">.</span><span class="nx">addChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="na">componentWillUnmount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">DataSource</span><span class="p">.</span><span class="nx">removeChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="na">handleChange</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
      <span class="p">});</span>
    <span class="p">},</span>

    <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// ... and renders the wrapped component with the fresh data!</span>
      <span class="k">return</span> <span class="o">&lt;</span><span class="nx">WrappedComponent</span> <span class="nx">comments</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">comments</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span>    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre>
</div>

<p>现在我们能够通过对<code class="highlighter-rouge">CommentList</code>调用<code class="highlighter-rouge">withSubscription</code>来定义<code class="highlighter-rouge">CommentListWithSubscription</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">CommentList</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">comments</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">comments</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="nx">comments</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comment</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Comment</span> <span class="nx">comment</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">}</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="p">})}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// withSubscription() returns a new component that</span>
<span class="c1">// is subscribed to the data source and renders</span>
<span class="c1">// &lt;CommentList /&gt; with up-to-date data.</span>
<span class="kd">var</span> <span class="nx">CommentListWithSubscription</span> <span class="o">=</span> <span class="nx">withSubscription</span><span class="p">(</span><span class="nx">CommentList</span><span class="p">);</span>

<span class="c1">// The rest of the app is interested in the subscribed component</span>
<span class="c1">// so we export it instead of the original unwrapped CommentList.</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">CommentListWithSubscription</span><span class="p">;</span>
</code></pre>
</div>
<p>完整的解决方案如下。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">withSubscription</span><span class="p">(</span><span class="nx">WrappedComponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
    <span class="na">getInitialState</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
      <span class="p">};</span>
    <span class="p">},</span>

    <span class="na">componentDidMount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">DataSource</span><span class="p">.</span><span class="nx">addChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="na">componentWillUnmount</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">DataSource</span><span class="p">.</span><span class="nx">removeChangeListener</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">handleChange</span><span class="p">);</span>
    <span class="p">},</span>

    <span class="na">handleChange</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
        <span class="na">comments</span><span class="p">:</span> <span class="nx">DataSource</span><span class="p">.</span><span class="nx">getComments</span><span class="p">()</span>
      <span class="p">});</span>
    <span class="p">},</span>

    <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Use JSX spread syntax to pass all props and state down automatically.</span>
      <span class="k">return</span> <span class="o">&lt;</span><span class="nx">WrappedComponent</span> <span class="p">{...</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">}</span> <span class="p">{...</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span>    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="c1">// Optional change: convert CommentList to a functional component</span>
<span class="c1">// because it doesn't use lifecycle hooks or state.</span>
<span class="kd">function</span> <span class="nx">CommentList</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">comments</span> <span class="o">=</span> <span class="nx">props</span><span class="p">.</span><span class="nx">comments</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">comments</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">comment</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Comment</span> <span class="nx">comment</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">}</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">comment</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="p">})}</span>
    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Instead of declaring CommentListWithSubscription,</span>
<span class="c1">// we export the wrapped component right away.</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">withSubscription</span><span class="p">(</span><span class="nx">CommentList</span><span class="p">);</span>
</code></pre>
</div>

<p>Higher-order component是非常强大的模式。你可以传额外的参数给他们如果你想要深度定制行为的话。毕竟他们都不是React的特性。他们仅仅是接收组件，并返回新的组件的函数而已。</p>

<p>如同其他任何解决方案。higher-order components有其自己的缺点。例如，如果你大量依赖refs，你会发现refs会指向包装好之后的组件。但实际上我们是不建议大量使用refs的，所以这也不应该成为大问题。未来我们可能通过增加ref forwarding来解决这个问题。</p>

<h2 id="rendering-logic">Rendering Logic</h2>
<p>下一个在我们代码库中比较常见的应用case是在不同的组件之间分享rendering逻辑。如下。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">RowMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1">// Called by components from render()</span>
  <span class="na">renderHeader</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s1">'row-header'</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span>
          <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">getHeaderText</span><span class="p">()</span> <span class="cm">/* Defined by components */</span><span class="p">}</span>
        <span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">UserRow</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">mixins</span><span class="p">:</span> <span class="p">[</span><span class="nx">RowMixin</span><span class="p">],</span>

  <span class="c1">// Called by RowMixin.renderHeader()</span>
  <span class="na">getHeaderText</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">fullName</span><span class="p">;</span>
  <span class="p">},</span>

  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">renderHeader</span><span class="p">()</span> <span class="cm">/* Defined by RowMixin */</span><span class="p">}</span>
        <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">biography</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>
</div>

<p>不同的组件可能共享RowMixin来展示header，他们都必须要定义<code class="highlighter-rouge">getHeaderText()</code>函数。</p>

<h3 id="section-3">解决方案</h3>
<p>如果你发现mixin中存在render逻辑，那么是时候改抽取component了。我们定义<code class="highlighter-rouge">Row</code>组件来替代<code class="highlighter-rouge">RowMixin</code>。我们使用传统的传递props的方式来替换掉<code class="highlighter-rouge">getHeaderText()</code>函数。</p>

<p>最后，因为这些组件都不需要生命周期的hook，所以我们用单纯的函数就可以了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">RowHeader</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="s1">'row-header'</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">text</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">UserRow</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">RowHeader</span> <span class="nx">text</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">fullName</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="nx">h2</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">biography</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h2</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>  <span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>props让组件之间的依赖关系变得显示，容易替换。使得Flow以及TypeScript这样的工具能够有用武之地。</p>

<h2 id="context">Context</h2>
<p>另外一组Mixin我们发现是React context的帮助工具。Context是一个不太成熟的，不稳定的方案，有一些特定的问题，而且其API很有可能会在将来改变。我们是不推荐使用的，除非你真的不能通过其他方式来解决这个问题。</p>

<p>如果你已经开始使用context，那你可能使用了如下的mixin来隐藏其使用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">RouterMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">contextTypes</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">router</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PropTypes</span><span class="p">.</span><span class="nx">object</span><span class="p">.</span><span class="nx">isRequired</span>
  <span class="p">},</span>

  <span class="c1">// The mixin provides a method so that components</span>
  <span class="c1">// don't have to use the context API directly.</span>
  <span class="na">push</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Link</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">mixins</span><span class="p">:</span> <span class="p">[</span><span class="nx">RouterMixin</span><span class="p">],</span>

  <span class="na">handleClick</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>

    <span class="c1">// This method is defined in RouterMixin.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">to</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">a</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">Link</span><span class="p">;</span>
</code></pre>
</div>

<h3 id="section-4">解决方案</h3>
<p>我们也认为在使用组件的使用隐藏context的使用是好想法，前提是context的API稳定。然而我们建议使用Higher-order Component来替换mixin。</p>

<p>下面我们使用来自context中的一些东西来包装组件，然后通过props传递给被包装的组件。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">withRouter</span><span class="p">(</span><span class="nx">WrappedComponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
    <span class="na">contextTypes</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">router</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">PropTypes</span><span class="p">.</span><span class="nx">object</span><span class="p">.</span><span class="nx">isRequired</span>
    <span class="p">},</span>

    <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// The wrapper component reads something from the context</span>
      <span class="c1">// and passes it down as a prop to the wrapped component.</span>
      <span class="kd">var</span> <span class="nx">router</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">context</span><span class="p">.</span><span class="nx">router</span><span class="p">;</span>
      <span class="k">return</span> <span class="o">&lt;</span><span class="nx">WrappedComponent</span> <span class="p">{...</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">}</span> <span class="nx">router</span><span class="o">=</span><span class="p">{</span><span class="nx">router</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span>    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Link</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">handleClick</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">e</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">();</span>

    <span class="c1">// The wrapped component uses props instead of context.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">router</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">to</span><span class="p">);</span>
  <span class="p">},</span>

  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">a</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/a</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// Don't forget to wrap the component!</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">withRouter</span><span class="p">(</span><span class="nx">Link</span><span class="p">);</span>
</code></pre>
</div>

<p>如果你正在使用的第三方库只提供了mixin，我们建议你提issue，并加上本文的链接，以便他们通过higher-order component来重写。同时，我们建议你应该多使用higher-order component。</p>

<h2 id="utility-methods">Utility Methods</h2>
<p>某些时候，mixin仅仅是用来在不同的组件之间共享功能。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">ColorMixin</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">getLuminance</span><span class="p">(</span><span class="nx">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">color</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="kd">var</span> <span class="nx">r</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&amp;</span> <span class="mh">0xFF0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&amp;</span> <span class="mh">0x00FF00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c</span> <span class="o">&amp;</span> <span class="mh">0x0000FF</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">0.299</span> <span class="o">*</span> <span class="nx">r</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="nx">g</span> <span class="o">+</span> <span class="mf">0.114</span> <span class="o">*</span> <span class="nx">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">Button</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">mixins</span><span class="p">:</span> <span class="p">[</span><span class="nx">ColorMixin</span><span class="p">],</span>

  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">theme</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getLuminance</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">160</span> <span class="p">?</span> <span class="s1">'dark'</span> <span class="p">:</span> <span class="s1">'light'</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">theme</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>
</div>

<h3 id="section-5">解决方案</h3>
<p>将工具方法提取到JavaScript模块中，然后import他们。这样也能更好的保证可测试性。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">getLuminance</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'../utils/getLuminance'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">Button</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="na">render</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">theme</span> <span class="o">=</span> <span class="nx">getLuminance</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">color</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">160</span> <span class="p">?</span> <span class="s1">'dark'</span> <span class="p">:</span> <span class="s1">'light'</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span> <span class="nx">className</span><span class="o">=</span><span class="p">{</span><span class="nx">theme</span><span class="p">}</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">children</span><span class="p">}</span>
      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>
</div>

<h2 id="case">其他使用Case</h2>
<p>有时候，人们使用mixins来选择性的在不同的生命周期hook中添加log。未来，我们倾向于提供官方的调试API（<code class="highlighter-rouge">official DevTools API</code>）让你来实现类似的功能而不能更改组件的代码。但这一切还正在进行中。如果你的项目中重度依赖mixin来打log，那么你可能还需要等待更久一点的时间。</p>

<p>如果某些情况下你不同通过实现组件、higher-order component或者工具模块来解决问题，很有可能是因为React本身不能解决这个问题了，记得给我们提issue，我们会尽快提供可选方案，或者实现新的特性。</p>

<p>Mixins并没有被废弃。你依然可以使用Mixin当你使用<code class="highlighter-rouge">React.createClass()</code>，未来我们也不会改变它。最后ES6类方法越来越受到很多人使用，未来可能我们会将<code class="highlighter-rouge">React.createClass()</code>拆分到不同的包中，因为大部分人可能不会再需要使用它们。即使是这种情况，老的mixin也能继续使用。</p>

<p>我们坚信上面给出的替代方案在大部分情况下是要比mixin更好，我们邀请各位写无mixin的React app。</p>


  </article>
</div>

      </div>
    </div>

    <footer class="footer">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="2016-07-20 00:00:00 +0800" data-title="Mixins Considered Harmful" data-url="/js/react/2016/07/20/Mixins-Considered-Harmful.html"></div>
  <!-- 多说评论框 end -->
  <!-- 多说最新评论 start -->
  <div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div>
  <!-- 多说最新评论 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"rookie-nerd"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
  <!-- 多说公共JS代码 end -->
  <div id="gotop">^</div>
  <br>
	@2015 Pithy Theme by Pawpaw.
</footer>

    
  </body>

</html>
